---
layout: post
category: "other"
title:  "设计模式"
tags: [设计模式]
---
**设计模式**

* 一个系统设计的基本原则: 开闭原则（对扩展开放；对修改封闭）

* 1,单例模式

 * 单例模式--
 * 使用场景
 * 1.需要频繁实例化然后销毁的对象。
 * 2.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。
 * 3.有状态的工具类对象。
 * 4.频繁访问数据库或文件的对象。

			public class MySingleController {
			    //恶汉式
			    /*private static MySingleController msc = new MySingleController();
			    public static MySingleController getIntance() {
			        return msc;
			    }*/
			
			    //懒汉式
			    /*private static MySingleController msc = null;
			    public static MySingleController getIntance() {
			        if(msc == null)msc = new MySingleController();
			        return msc;
			    }*/
			
			    //上述的俩种方法在单线程的模式下是没有问题的。
			    //如果是多线程的模式下的话需要使用锁synchronized来避免多线程问题
			    /*private static MySingleController msc = null;
			    public static synchronized MySingleController getIntance() {
			        if(msc == null)msc = new MySingleController();
			        return msc;
			    }*/
			
			    //上述方法虽然可以避免多线的问题，但是由于对整个方法使用了synchronized，因此会造成性能问题
			    //所以可以进一步进行优化
			    private static MySingleController msc = null;
			    public static MySingleController getIntance() {
			        if(msc == null){
			            synchronized (MySingleController.class) {
			                //这样做也是为了避免多线程环境下new出多个单例
			                if(msc == null)msc = new MySingleController();
			            }
			        }
			        return msc;
			    }
			
			}

* 2,观察者模式

当需要观察一个对象在特定的情况下的不同动作的时候使用

 * 观察者对象
 * 通常观察者模式会和单例一起使用，作为一个系统的观察者，来为各个页面发送通知。相当于一个事件的处理器---事件总线
	
		public class MyObserveable {
		
		    private final ArrayList<MyObserver> arr;
		
		    public MyObserveable(){
		        arr = new ArrayList<>();
		    }
		
		    public void addOberver(MyObserver ob) {
		        arr.add(ob);
		    }
		
		    public void removeOberver(MyObserver ob) {
		        arr.remove(ob);
		    }
		
		    public void notifyObserver() {
		        notifyObserver(null);
		    }
		
		    public void notifyObserver(String tag) {
		        if(arr == null || arr.size() == 0)return;
		        while (true) {
		            Iterator<MyObserver> it = arr.iterator();
		            if(it.hasNext()) {
		                MyObserver ob = it.next();
		                ob.onUpdate(tag);
		            }
		        }
		    }
		
		
		}

 * 观察者
		
		public interface MyObserver {
		
		    void onUpdate(String tag);
		
		}
		
* 观察者模式
* 观察者模式的应用场景：
* 1、 对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。
* 2、 对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。
* 观察者模式的优点：
* 1、 Subject和Observer之间是松偶合的，分别可以各自独立改变。
* 2、 Subject在发送广播通知的时候，无须指定具体的Observer，Observer可以自己决定是否要订阅Subject的通知。
* 3、 遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。
* 观察者模式的缺陷：
* 1、 松偶合导致代码关系不明显，有时可能难以理解。(废话)
* 2、 如果一个Subject被大量Observer订阅的话，在广播通知的时候可能会有效率问题。（毕竟只是简单的遍历）

		public class MainObserver {
		
		    private static final MyObserver mo = new MyObserver() {
		        @Override
		        public void onUpdate(String tag) {
		            System.out.print("收到通知的消息：" + tag);
		        }
		    };
		
		    public static void main(String[] args) {
		        MyObserveable moa = new MyObserveable();
		        moa.addOberver(mo);
		        moa.notifyObserver("测试观察者");
		    }
		
		}

* 3,构建者模式 当一个类的内部数据过于复杂的时候 Builder模式可以将一个类的构建和表示进行分离

* 4,工厂模式

使用场景：一类产品有多个具体的产品族

1， 简单工厂模式

 * 又称静态工厂方法模式
 * 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑，用来创建产品
 
		public class MySimpleFactory {
		
		    public static final int BUS = 1;
		    public static final int BICYCLE = 2;
		
		    //
		    public Car createCar(int t) {
		        Car c = null;
		        switch (t) {
		            case BUS:
		                c = new Bus();
		                break;
		            case BICYCLE:
		                c = new Bicycle();
		                break;
		            default:
		                break;
		        }
		        return c;
		    }
		}

2，工厂方法模式

	public interface MyAbsMethodFactory {

    	Car createCar();

	}
	
	


3，抽象工厂模式

		public interface MyAbsFactory {
		
		    //创建发动机
		    Engine createEngine();
		    //创建空调
		    Aircondition createAircondition();
		
		}
	
工厂方法的具体实现	
		
	 public class MyBicycleFactory implements MyAbsMethodFactory {
	    @Override
	    public Car createCar() {
	        return new Bicycle();
	    }
	}



* 5,代理模式 这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法 

 * 静态代理
 * 可以做到在不修改目标对象的功能前提下,对目标功能扩展.
 * 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.
 * 同时,一旦接口增加方法,目标对象与代理对象都要维护.


			public class UserProxy implements IUserDao {
			
			    private IUserDao mUser;
			
			    public UserProxy(IUserDao user){
			        mUser = user;
			    }
			
			    @Override
			    public void add(User user) {
			        mUser.add(user);
			    }
			
			    @Override
			    public void delete(int id) {
			        mUser.delete(id);
			    }
			
			    @Override
			    public void update(int id) {
			        mUser.update(id);
			    }
			
			    @Override
			    public void quey(int id) {
			        mUser.quey(id);
			    }
			}
  
 * 1.代理对象,不需要实现接口
 * 2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)
 * .动态代理也叫做:JDK代理,接口代理
 * JDK中生成代理对象的API
 * 代理类所在包:java.lang.reflect.Proxy
 * 目标对象实现的接口的类型,使用泛型方式确认类型
 * 使用了反射机制，对性能会造成影响

		public class DynamicPorxy {
		
		    private Object target;
		
		    public DynamicPorxy(Object target) {
		        this.target = target;
		    }
		
		    ////给目标对象生成代理对象给目标对象生成代理对象
		    public Object getProxyInstance() {
		        return Proxy.newProxyInstance(target.getClass().getClassLoader(),
		                target.getClass().getInterfaces(), new InvocationHandler() {
		                    @Override
		                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		
		                        Object value = method.invoke(target, args);
		
		                        return value;
		                    }
		                });
		    }
	
	}
	

* 6,适配器模式 适配器更多的是作为一个中间层来实现这种转换作用

* 7，建造者模式

 * 构建者模式
 * 当一个类的内部数据过于复杂的时候（通常是负责持有数据的类，比如Config、VO、PO、Entity...）
 * Builder模式可以将一个类的构建和表示进行分离。

	public class User {
	
	    private String name;
	    private String sex;
	    private int age;
	
	    private User(Builder builder) {
	        name = builder.name;
	        sex = builder.sex;
	        age = builder.age;
	    }
	
	
	    public static class Builder {
	
	        private String name;
	        private String sex;
	        private int age;
	
	        public Builder() {
	        }
	
	        public Builder name(String val) {
	            name = val;
	            return this;
	        }
	
	        public Builder sex(String val) {
	            sex = val;
	            return this;
	        }
	
	        public Builder age(int val) {
	            age = val;
	            return this;
	        }
	
	        public User build() {
	            return new User(this);
	        }
	    }
	
	}	
	